# AINovelAgent 编码规范

## 📋 文档概述

**文档用途**: 严格限制AINovelAgent项目的编码规范和最佳实践，并在代码审核时决定代码是否通过验收。  

## 🎯 核心原则

### 1. SOLID原则
- **S** - 单一职责原则 (Single Responsibility Principle)
- **O** - 开闭原则 (Open/Closed Principle)  
- **L** - 里氏替换原则 (Liskov Substitution Principle)
- **I** - 接口隔离原则 (Interface Segregation Principle)
- **D** - 依赖倒置原则 (Dependency Inversion Principle)

### 2. 设计原则
- **DRY** - Don't Repeat Yourself (不要重复自己)
- **KISS** - Keep It Simple, Stupid (保持简单)
- **YAGNI** - You Aren't Gonna Need It (你不会需要它)

## 🏗️ 项目架构规范

### 1. 分层架构
```
├── Models/                 # 数据模型层
│   ├── Base/              # 基础模型
│   ├── Configuration/     # 配置模型
│   └── Project/           # 项目模型
├── Services/              # 业务服务层
│   ├── Interfaces/        # 服务接口
│   ├── Configuration/     # 配置服务
│   └── File/              # 文件服务
├── ViewModels/            # 视图模型层
│   ├── Base/              # 基础视图模型
│   └── Main/              # 主窗口视图模型
├── Views/                 # 视图层
│   ├── Base/              # 基础视图
│   ├── Main/              # 主窗口视图
│   └── Controls/          # 自定义控件
├── Utils/                 # 工具类
│   ├── Commands/          # 命令实现
│   ├── Converters/        # 值转换器
│   └── Extensions/        # 扩展方法
└── Configuration/         # 配置类
    └── ServiceConfiguration.cs
```

### 2. 依赖关系规则
- 上层依赖下层，下层不依赖上层
- 通过接口实现依赖倒置
- 使用依赖注入管理服务实例
- 禁止循环依赖

## 📝 C# 编码规范

### 1. 命名规范

#### 类命名
- 使用PascalCase命名
- 类名应该是名词，描述性强
- 避免使用缩写，除非是广泛认知的缩写

#### 接口命名
- 以"I"开头，使用PascalCase
- 接口名应该是形容词或名词
- 避免使用"I"前缀的缩写形式

#### 方法命名
- 使用PascalCase命名
- 方法名应该是动词或动词短语
- 异步方法以"Async"结尾

#### 属性命名
- 使用PascalCase命名
- 属性名应该是名词或形容词
- 布尔属性使用"Is"、"Has"、"Can"等前缀

#### 字段命名
- 私有字段使用下划线前缀 + camelCase
- 常量使用全大写，下划线分隔
- 静态只读字段使用PascalCase

### 2. 代码格式规范

#### 缩进和空格
- 使用4个空格缩进，不使用Tab
- 大括号换行放置
- 操作符前后添加空格
- 逗号后添加空格

#### 代码组织
- using语句按字母顺序排列
- 类成员按访问修饰符分组
- 相关方法放在一起

### 3. 异常处理规范

#### 异常抛出
- 使用具体的异常类型，避免使用通用Exception
- 提供有意义的错误消息
- 使用nameof()获取参数名称
- 在构造函数中验证参数

#### 异常捕获
- 捕获具体的异常类型
- 记录异常信息
- 不要忽略异常
- 使用finally块清理资源

### 4. 异步编程规范

#### 异步方法
- 异步方法以"Async"结尾
- 返回Task或Task<T>
- 使用ConfigureAwait(false)避免死锁
- 避免在库代码中使用ConfigureAwait(true)

#### 异步调用
- 使用await而不是.Result或.Wait()
- 避免在UI线程上阻塞
- 正确处理异步异常

## 🎨 WPF 编码规范

### 1. XAML 规范

#### 命名空间声明
- 按字母顺序排列命名空间
- 使用有意义的别名
- 避免使用通配符命名空间

#### 属性顺序
- 按重要性排序属性
- 数据绑定属性优先
- 布局属性其次
- 样式属性最后

#### 数据绑定
- 优先使用数据绑定而不是事件处理
- 使用强类型绑定
- 避免在XAML中硬编码值

### 2. 代码后置规范

#### 事件处理
- 最小化代码后置文件
- 事件处理应该简洁
- 将复杂逻辑移至ViewModel
- 避免在事件处理中编写业务逻辑

## 🏛️ MVVM 编码规范

### 1. ViewModel 规范

#### 基类继承
- 所有ViewModel继承ViewModelBase
- 通过构造函数注入依赖
- 实现INotifyPropertyChanged接口
- 使用CommunityToolkit.Mvvm特性

#### 属性定义
- 使用[ObservableProperty]特性简化属性定义
- 复杂属性自定义实现
- 属性变更时触发通知
- 避免在属性setter中执行复杂逻辑

#### 命令定义
- 使用[RelayCommand]特性定义命令
- 命令应该简洁，复杂逻辑委托给服务
- 异步命令使用AsyncRelayCommand
- 命令应该验证CanExecute状态

### 2. View 规范

#### 数据绑定
- 优先使用命令绑定而不是事件处理
- 使用属性绑定显示数据
- 避免在XAML中硬编码值
- 使用转换器处理数据格式

#### 代码后置
- 最小化代码后置文件
- 只处理UI相关的逻辑
- 通过DataContext访问ViewModel
- 避免在View中编写业务逻辑

## 🧵 Fody（PropertyChanged.Fody）使用规范

### 1. 目标与适用范围
- 目标：减少手写 INotifyPropertyChanged 样板代码，提升开发效率与一致性。
- 适用：模型层（Models）与需要最小侵入式通知支持的简单类；视图模型层（ViewModels）仅在明确约定时使用。

### 2. 与 CommunityToolkit.Mvvm 的关系
- ViewModels 层默认使用 CommunityToolkit.Mvvm（如 ObservableObject、[ObservableProperty]）。
- 避免在同一个类中同时使用 Fody 与 CommunityToolkit.Mvvm 的通知机制（不可混用）。
- 推荐策略：
  - ViewModels：优先使用 CommunityToolkit.Mvvm；仅在确需 Fody 风格时统一评审后采用。
  - Models：可使用 Fody 以保持 POCO 风格，减少依赖。

### 3. 使用准则（无示例）
- 仅为需要变更通知的属性开启通知；避免为大量只读/常量数据启用。
- 避免在属性 setter 的通知链中放置重逻辑/耗时操作。
- 当属性之间存在依赖关系时，需明确维护依赖通知关系，并避免循环通知。
- 变更通知的命名需与属性保持一致；变更语义应清晰、可预期。

### 4. 配置与构建
- 保持 FodyWeavers.xml 在版本控制中，并与团队共享一致的配置。
- 构建为编织点（weaving）执行阶段；遇到构建异常时，优先检查 Fody 配置与属性命名。
- 避免在同一解决方案中为同一程序集启用多个通知方式的编织器配置。

### 5. 代码评审要点
- 是否存在 Fody 与 CommunityToolkit.Mvvm 的混用。
- 是否只为必要的属性开启通知，避免滥用。
- 是否存在潜在的循环通知或高开销通知路径。
- 是否有一致的跨层策略（ViewModels 用 Toolkit，Models 可用 Fody）。

### 6. 兼容性与风险控制
- 在引入或调整 Fody 配置前，需进行最小化 PoC 验证与构建测试。
- 发生通知时序变更引发的问题，应通过单元测试与集成测试覆盖关键属性流程。
- 对关键领域对象的通知策略变更需记录在变更日志中。

## 🔧 依赖注入规范

### 1. 服务注册规范

#### 服务接口定义
- 接口定义应该清晰简洁
- 遵循单一职责原则
- 避免接口过于复杂
- 使用有意义的接口名称

#### 服务实现
- 实现对应的接口
- 遵循单一职责原则
- 通过构造函数注入依赖
- 实现应该是无状态的（单例）或有状态的（瞬态）

#### 服务注册
- 按生命周期注册服务
- 单例服务：无状态，可共享
- 瞬态服务：有状态，每次创建新实例
- 作用域服务：在特定范围内共享

### 2. 构造函数注入规范

#### 构造函数设计
- 验证所有参数
- 使用null检查抛出ArgumentNullException
- 避免过多的构造函数参数
- 使用工厂模式处理复杂依赖

## 📊 性能优化规范

### 1. 内存管理
- 使用using语句释放资源
- 实现IDisposable接口
- 避免内存泄漏
- 及时释放不需要的对象

### 2. 异步操作
- 避免阻塞UI线程
- 使用异步方法处理长时间操作
- 正确使用ConfigureAwait
- 避免死锁

### 3. 数据绑定
- 避免频繁的属性变更
- 使用批量更新
- 优化数据转换
- 避免不必要的绑定

## 🧪 测试规范

### 1. 单元测试
- 测试用例命名：方法名_条件_期望结果
- 使用AAA模式：Arrange、Act、Assert
- 测试正常情况和异常情况
- 使用Mock对象隔离依赖

### 2. 集成测试
- 测试组件间的交互
- 使用真实的依赖关系
- 测试完整的业务流程
- 验证端到端功能

## 📚 文档规范

### 1. XML文档注释
- 为所有公共API提供XML文档注释
- 描述方法的目的和行为
- 说明参数和返回值
- 列出可能的异常

### 2. 代码注释
- 解释为什么，而不是做什么
- 注释复杂的业务逻辑
- 避免显而易见的注释
- 保持注释与代码同步

## 🚫 禁止事项

### 1. 代码质量
- 禁止使用var关键字（除非类型显而易见）
- 禁止使用goto语句
- 禁止使用dynamic关键字
- 禁止使用ref和out参数（除非必要）
- 禁止使用unsafe代码

### 2. 架构设计
- 禁止在View中编写业务逻辑
- 禁止在ViewModel中直接操作UI控件
- 禁止在Service中直接操作UI
- 禁止循环依赖
- 禁止硬编码字符串和数字

### 3. 性能问题
- 禁止在UI线程上执行长时间操作
- 禁止内存泄漏（忘记释放资源）
- 禁止同步等待异步操作
- 禁止在循环中创建大量对象

## 📋 代码审查清单

### 提交前检查
- [ ] 代码符合命名规范
- [ ] 异常处理完整
- [ ] 资源正确释放
- [ ] 异步操作使用正确
- [ ] 单元测试通过
- [ ] 代码注释完整
- [ ] 无编译警告
- [ ] 符合MVVM模式
- [ ] 依赖注入使用正确
- [ ] 性能优化到位

## 🔄 持续改进

### 定期审查
- 每月进行代码质量审查
- 每季度更新编码规范
- 定期进行技术债务清理
- 持续学习最佳实践

---

**注意**: 本规范是强制性的，所有代码必须严格遵循。如有疑问，请及时沟通讨论。
